<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur de PDFs d'Examen</title>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #052E2B, #0F766E, #A7F3D0);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 600px;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
            text-align: center;
        }

        .subtitle {
            color: #666;
            text-align: center;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .upload-section {
            margin-bottom: 25px;
        }

        label {
            display: block;
            color: #555;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 2px dashed #667eea;
            border-radius: 10px;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        input[type="file"]:hover {
            border-color: #764ba2;
            background: #f0f1ff;
        }

        button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #2A0A12, #9F1239, #FDA4AF);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .progress {
            margin-top: 20px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 12px;
        }

        .progress-text {
            text-align: center;
            color: #666;
            font-size: 14px;
        }

        .info-box {
            background: #e8f4ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .info-box p {
            color: #555;
            font-size: 13px;
            line-height: 1.6;
            margin-bottom: 5px;
        }

        .info-box p:last-child {
            margin-bottom: 0;
        }

        .success {
            background: #d4edda;
            border-left-color: #28a745;
        }

        .error {
            background: #f8d7da;
            border-left-color: #dc3545;
        }

        select, input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #667eea;
            border-radius: 10px;
            background: #f8f9ff;
            font-size: 14px;
            color: #333;
            transition: all 0.3s ease;
            appearance: auto;
        }

        select:hover, input[type="text"]:hover {
            border-color: #764ba2;
            background: #f0f1ff;
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: #764ba2;
            box-shadow: 0 0 0 3px rgba(118, 75, 162, 0.2);
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìÑ G√©n√©rateur d'examens avec nom, matricule et num√©ro de table</h1>
        <p class="subtitle">Possibilit√© de g√©n√©rer des listes de pr√©sence</p>

        <div class="info-box">
            <p><strong>Le CSV ou XLSX doit avoir ces colonnes au minimum :</strong></p>
            <p>‚Ä¢ Pr√©nom et nom (s√©par√©s ou non)</p>
            <p>‚Ä¢ Num√©ro d'identification (NI)</p>
            <p>‚Ä¢ Num√©ro de table</p>
            <p>‚Ä¢ Local</p>
            <p>‚Ä¢ Section</p>
        </div>

        <div class="upload-section">
            <label for="csvFile">üìä Fichier CSV ou XLSX des √©tudiants</label>
            <input type="file" id="csvFile" accept=".csv,.xlsx" required>
            <div id="detectionResult" style="margin-top:10px;font-size:13px;color:#333"></div>
        </div>

        <div class="upload-section">
            <label for="accomFile">üü™ Fichier d'accommodements (optionnel)</label>
            <input type="file" id="accomFile" accept=".csv,.xlsx">
            <div id="accomMap" style="margin-top:10px;font-size:13px;color:#333;display:none;">
                <label for="accomNiSelect">Colonne contenant le num√©ro de dossier (NI)</label>
                <select id="accomNiSelect"></select>
            </div>
        </div>

        <div class="upload-section">
            <label for="filterFiles">üîç Fichiers de liste (optionnel) ‚Äî plusieurs accept√©s</label>
            <input type="file" id="filterFiles" accept=".csv,.xlsx" multiple>
            <div id="filterResult" style="margin-top:10px;font-size:13px;color:#333;display:none;"></div>
        </div>

        <div class="upload-section" id="mappingUI" style="display:none;">
            <label>üîß V√©rifier / choisir les colonnes</label>
            <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;">
                <input type="checkbox" id="nameSeparate"> <label for="nameSeparate" style="margin:0;font-weight:600;">Nom s√©par√© en Pr√©nom / Nom</label>
            </div>
            <div style="display:flex;gap:8px;margin-bottom:8px;">
                <div style="flex:1">
                    <label for="nameCombinedSelect">Pr√©nom et nom (combin√©)</label>
                    <select id="nameCombinedSelect"></select>
                </div>
                <div style="flex:1">
                    <label for="firstNameSelect">Pr√©nom (s√©par√©)</label>
                    <select id="firstNameSelect"></select>
                </div>
                <div style="flex:1">
                    <label for="lastNameSelect">Nom (s√©par√©)</label>
                    <select id="lastNameSelect"></select>
                </div>
            </div>
            <div style="display:flex;gap:8px;margin-bottom:8px;">
                <div style="flex:1">
                    <label for="niSelect">Num√©ro d'identification (NI)</label>
                    <select id="niSelect"></select>
                </div>
            </div>
            <div style="font-size:12px;color:#666">Conseil : v√©rifiez et modifiez si n√©cessaire avant de g√©n√©rer.</div>
        </div>

        <div class="upload-section">
            <label for="pdfFile">üìë Mod√®le PDF de l'examen</label>
            <input type="file" id="pdfFile" accept=".pdf" required>
        </div>

        <!-- attribution handled automatically by the single action button -->

        <div id="roomsUI" style="margin-bottom:16px;">
            <label>üè∑Ô∏è Choisir les locaux √† utiliser</label>
            <div id="roomList" style="margin-top:8px;">
                <div class="roomRow" style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
                    <input type="checkbox" class="roomCheckbox" data-name="VCH-2850" id="room_VCH-2850" checked>
                    <label for="room_VCH-2850" style="margin:0;font-weight:600;">VCH-2850</label>
                    <input type="number" class="roomCapacity" data-name="VCH-2850" value="201" min="1" style="width:100px;margin-left:8px;">
                    <div style="font-size:12px;color:#666;margin-left:8px;">places</div>
                </div>
                <div class="roomRow" style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
                    <input type="checkbox" class="roomCheckbox" data-name="VCH-2880" id="room_VCH-2880" checked>
                    <label for="room_VCH-2880" style="margin:0;font-weight:600;">VCH-2880</label>
                    <input type="number" class="roomCapacity" data-name="VCH-2880" value="110" min="1" style="width:100px;margin-left:8px;">
                    <div style="font-size:12px;color:#666;margin-left:8px;">places</div>
                </div>
            </div>
            <div style="font-size:12px;color:#666">Cochez les locaux √† utiliser et modifiez la capacit√© si besoin.</div>
        </div>

        <div class="upload-section">
            <label>üìã G√©n√©rer une liste de pr√©sence ?</label>
            <div style="display:flex;align-items:center;gap:12px;margin-top:8px;">
                <input type="checkbox" id="createList">
                <label for="createList" style="margin:0">Oui</label>
                <div style="display:flex;align-items:center;gap:8px;margin-left:12px;">
                    <label style="font-size:13px;margin-right:6px;">Format:</label>
                    <label><input type="radio" name="listFormat" value="local" checked> Par local</label>
                    <label><input type="radio" name="listFormat" value="section"> Par section</label>
                </div>
            </div>
        </div>

        <div class="upload-section">
            <label for="evalName">üìù Nom de l'√©valuation (obligatoire)</label>
            <input type="text" id="evalName" placeholder="Ex: Examen 1">
        </div>
        <div class="upload-section">
            <label for="courseName">üìö Num√©ro du cours (obligatoire)</label>
            <input type="text" id="courseName" placeholder="Ex: STT-1500">
        </div>

        <button id="generateBtn" onclick="generateAll()">
            üöÄ G√©n√©rer et T√©l√©charger le ZIP
        </button>

        <div class="progress" id="progress">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Initialisation...</div>
        </div>
    </div>

    <script>
        const { PDFDocument, rgb, StandardFonts } = PDFLib;

        // ========== CONFIGURATION DES POSITIONS ==========
        // Ajustez ces valeurs si les √©l√©ments ne sont pas parfaitement positionn√©s
        const CONFIG = {
            // Position du nom (en haut √† droite)
            nomX: 445,
            nomY: 88,  // Distance depuis le haut de la page
            nomSize: 12,
            
            // Position du NI (sous le nom)
            niX: 450,
            niY: 147,  // Distance depuis le haut de la page
            niSize: 16,
            
            // Position du num√©ro de table (coin bas droit)
            tableX: 88,  // Distance depuis le bord droit
            tableY: 38,  // Distance depuis le bas
            tableSize: 16
            ,
            // Position du local (coin bas gauche sur la page de couverture)
            localX: 40,
            localY: 38,
            localSize: 12
        };
        // ==================================================

        async function generatePDFs() {
            const csvFile = document.getElementById('csvFile').files[0];
            const pdfFile = document.getElementById('pdfFile').files[0];
            const evalName = document.getElementById('evalName').value.trim();
            const courseName = document.getElementById('courseName').value.trim();

            if (!csvFile || !pdfFile) {
                alert('‚ö†Ô∏è Veuillez s√©lectionner les deux fichiers (CSV/XLSX et PDF)');
                return;
            }

            // course and exam name are mandatory
            if (!evalName || !courseName) {
                alert('‚ö†Ô∏è Veuillez saisir le nom de l\'√©valuation et le num√©ro du cours.');
                return;
            }

            const createList = document.getElementById('createList').checked;
            const listFormat = document.querySelector('input[name="listFormat"]:checked') ? document.querySelector('input[name="listFormat"]:checked').value : 'local';

            const progressDiv = document.getElementById('progress');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const generateBtn = document.getElementById('generateBtn');

            try {
                // D√©sactiver le bouton et afficher la progression
                generateBtn.disabled = true;
                progressDiv.style.display = 'block';
                progressFill.style.width = '10%';
                progressText.textContent = 'Lecture des fichiers...';

                    // Lire le CSV ou XLSX
                    let students = [];
                    if (csvFile.name.toLowerCase().endsWith('.xlsx')) {
                        const arrayBuffer = await csvFile.arrayBuffer();
                        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                        // parcourir toutes les feuilles, section = nom de la feuille
                        for (const sheetName of workbook.SheetNames) {
                            const sheet = workbook.Sheets[sheetName];
                            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                            if (!rows || rows.length <= 6) continue; // header at line 6, data from 7
                            const headerRow = (rows[5] || []).map(h => (h === undefined ? '' : String(h).trim()));
                            const detection = detectNameColumn(headerRow);
                            const niIndex = detectSingleColumn(headerRow, ['ni','matricule','identifiant','id','numero','num','dossier']);
                            for (let r = 6; r < rows.length; r++) {
                                const row = rows[r] || [];
                                let name = '';
                                if (columnMapping.nameMode === 'separate' && columnMapping.firstIdx !== null && columnMapping.lastIdx !== null) {
                                    name = String(row[columnMapping.firstIdx] || '') + ' ' + String(row[columnMapping.lastIdx] || '');
                                } else if (columnMapping.nameIdx !== null) {
                                    name = String(row[columnMapping.nameIdx] || '');
                                } else if (detection.type === 'separate') {
                                    name = String(row[detection.indices[0]] || '') + ' ' + String(row[detection.indices[1]] || '');
                                } else if (detection.type === 'combined' && detection.indices.length === 1) {
                                    name = String(row[detection.indices[0]] || '');
                                } else {
                                    name = String(row[0] || '');
                                }
                                const ni = (niIndex >= 0 ? String(row[niIndex] || '') : (columnMapping.niIdx !== null ? String(row[columnMapping.niIdx] || '') : ''));
                                const email = '';
                                const status = 'Pr√©sent';
                                if (String(status).toLowerCase().includes('abandon')) {}
                                if (name || ni) students.push({ name: name.trim(), ni: ni.trim(), table: '', local: '', section: sheetName, email });
                            }
                        }
                    } else {
                        const csvText = await csvFile.text();
                        students = parseCSV(csvText);
                    }
                
                if (students.length === 0) {
                    throw new Error('Aucun √©tudiant trouv√© dans le CSV. V√©rifiez le format du fichier.');
                }

                // Si une attribution a √©t√© g√©n√©r√©e pr√©c√©demment, l'appliquer (par NI d'abord, sinon par nom normalis√©)
                if (typeof lastAssignments !== 'undefined' && lastAssignments && lastAssignments.length > 0) {
                    progressText.textContent = 'Application des attributions de places...';
                    const byNI = Object.create(null);
                    const byName = Object.create(null);
                    for (const a of lastAssignments) {
                        const niKey = (a.ni || '').toString().trim();
                        if (niKey) byNI[niKey] = a;
                        const nameKey = normalizeHeader(a.name || '');
                        if (nameKey) byName[nameKey] = a;
                    }
                    for (const s of students) {
                        let match = null;
                        const niKey = (s.ni || '').toString().trim();
                        if (niKey && byNI[niKey]) match = byNI[niKey];
                        else {
                            const nameKey = normalizeHeader(s.name || '');
                            if (nameKey && byName[nameKey]) match = byName[nameKey];
                        }
                        if (match) {
                            s.place = match.place || '';
                            s.table = match.place || '';
                            s.local = match.local || '';
                        }
                    }
                }

                console.log(`${students.length} √©tudiants trouv√©s:`, students);
                
                progressFill.style.width = '20%';
                progressText.textContent = `${students.length} √©tudiants trouv√©s...`;

                // Lire le PDF template
                const pdfBytes = await pdfFile.arrayBuffer();
                
                progressFill.style.width = '30%';
                progressText.textContent = 'Chargement du mod√®le PDF...';

                // Cr√©er un ZIP
                const zip = new JSZip();

                // G√©n√©rer un PDF pour chaque √©tudiant
                // R√©ordonner les √©tudiants : locaux avec le plus d'√©tudiants d'abord,
                // puis par num√©ro de place croissant √† l'int√©rieur de chaque local.
                const grouped = {};
                const unassigned = [];
                for (const s of students) {
                    const key = (s.local || '').toString() || '__UNASSIGNED__';
                    if (!key || key === '__UNASSIGNED__') {
                        unassigned.push(s);
                    } else {
                        if (!grouped[key]) grouped[key] = [];
                        grouped[key].push(s);
                    }
                }

                // Trier chaque groupe par place (num√©rique ascendant)
                for (const k of Object.keys(grouped)) {
                    grouped[k].sort((a,b) => {
                        const pa = parseInt(a.place, 10);
                        const pb = parseInt(b.place, 10);
                        if (isNaN(pa) && isNaN(pb)) return 0;
                        if (isNaN(pa)) return 1;
                        if (isNaN(pb)) return -1;
                        return pa - pb;
                    });
                }

                // Ordonner les locaux par taille (nombre d'√©tudiants) d√©croissante
                const localsSorted = Object.keys(grouped).sort((x,y) => grouped[y].length - grouped[x].length);

                // Construire la liste ordonn√©e finale
                const orderedStudents = [];
                for (const loc of localsSorted) orderedStudents.push(...grouped[loc]);
                // Ajouter les non assign√©s √† la fin (tri√©s par nom pour stabilit√©)
                unassigned.sort((a,b) => normalizeHeader(a.name||'').localeCompare(normalizeHeader(b.name||'')));
                orderedStudents.push(...unassigned);

                for (let i = 0; i < orderedStudents.length; i++) {
                    const student = orderedStudents[i];
                    const progress = 30 + (i / students.length) * 60;
                    progressFill.style.width = `${progress}%`;
                    progressText.textContent = `G√©n√©ration du PDF pour ${student.name}... (${i + 1}/${students.length})`;

                    console.log(`Traitement de l'√©tudiant ${i + 1}:`, student);

                    // Charger une nouvelle copie du PDF pour chaque √©tudiant
                    const pdfDoc = await PDFDocument.load(pdfBytes);
                    const pages = pdfDoc.getPages();
                    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);

                    console.log(`PDF charg√©, ${pages.length} pages trouv√©es`);

                    // Remplir les informations sur la premi√®re page
                    const firstPage = pages[0];
                    const { width, height } = firstPage.getSize();

                        // --- NOM (centr√© autour de CONFIG.nomX) ---
                        const nameText = student.name.toUpperCase();
                        const nameWidth = font.widthOfTextAtSize(nameText, CONFIG.nomSize);

                        firstPage.drawText(nameText, {
                        x: CONFIG.nomX - nameWidth / 2,
                        y: height - CONFIG.nomY,
                        size: CONFIG.nomSize,
                        font,
                        color: rgb(0, 0, 0),
                        });

                        // --- NI (centr√© autour de CONFIG.niX) ---
                        const niText = student.ni;
                        const niWidth = font.widthOfTextAtSize(niText, CONFIG.niSize);

                        firstPage.drawText(niText, {
                        x: CONFIG.niX - niWidth / 2,
                        y: height - CONFIG.niY,
                        size: CONFIG.niSize,
                        font,
                        color: rgb(0, 0, 0),
                        });
                        // --- LOCAL (bas gauche sur la page de couverture) ---
                        const localText = student.local || '';
                        if (localText) {
                            firstPage.drawText(localText, {
                                x: CONFIG.localX,
                                y: CONFIG.localY,
                                size: CONFIG.localSize,
                                font,
                                color: rgb(0, 0, 0),
                            });
                        }
                    // Num√©ro de table au bas de chaque page (coin inf√©rieur droit, DANS le rectangle)
                    for (let pageIndex = 0; pageIndex < pages.length; pageIndex++) {
                        const page = pages[pageIndex];
                        const { width: pageWidth } = page.getSize();
                        
                    for (let pageIndex = 0; pageIndex < pages.length; pageIndex++) {
                    const page = pages[pageIndex];
                    const { width: pageWidth } = page.getSize();

                    const tableText = student.table;
                    const tableWidth = font.widthOfTextAtSize(tableText, CONFIG.tableSize);

                    // Ton config actuel place le champ √† "pageWidth - tableX"
                    // On interpr√®te donc (pageWidth - tableX) comme le CENTRE du champ
                    const tableCenterX = pageWidth - CONFIG.tableX;

                    page.drawText(tableText, {
                        x: tableCenterX - tableWidth / 2,
                        y: CONFIG.tableY,
                        size: CONFIG.tableSize,
                        font,
                        color: rgb(0, 0, 0),
                    });
                    }
                    }

                    // Sauvegarder le PDF
                    const modifiedPdfBytes = await pdfDoc.save();
                    console.log(`PDF sauvegard√©, taille: ${modifiedPdfBytes.length} bytes`);
                    
                    // Ajouter au ZIP avec un nom de fichier nettoy√©
                    function padPlace(p) {
                        const n = parseInt(p, 10);
                        if (!isFinite(n) || isNaN(n)) return '000';
                        return String(n).padStart(3, '0');
                    }

                    const placePad = padPlace(student.place);
                    const localPart = sanitizeFileName(student.local || 'NOLOCAL');
                    const fileBase = buildFileBase(student);
                    const localIndexMap = ensureLocalIndexMap();
                    const localIndex = (student.local && localIndexMap[student.local]) ? localIndexMap[student.local] : 0;
                    const fullFileName = `${localIndex}${placePad}_${localPart}_${fileBase}.pdf`;
                    zip.file(fullFileName, modifiedPdfBytes);
                    console.log(`Ajout√© au ZIP: ${fullFileName}`);
                }

                // G√©n√©rer les listes de pr√©sence si demand√© via la nouvelle UI
                if (createList) {
                    progressFill.style.width = '92%';
                    progressText.textContent = 'G√©n√©ration des listes de pr√©sence...';

                    const groupBy = listFormat; // 'local' ou 'section'
                    const groups = {};
                    for (const student of students) {
                        const key = student[groupBy];
                        if (!groups[key]) groups[key] = [];
                        groups[key].push(student);
                    }

                    const groupKeys = Object.keys(groups).sort();
                    for (const groupValue of groupKeys) {
                        const attendancePdfBytes = await generateAttendancePDF(
                            groups[groupValue], groupBy, groupValue, evalName, courseName
                        );
                        const label = groupBy === 'local' ? 'Local' : 'Section';
                        const fileName = `listes_presence/Presence_${label}_${sanitizeFileName(groupValue)}.pdf`;
                        zip.file(fileName, attendancePdfBytes);
                    }
                }

                progressFill.style.width = '95%';
                progressText.textContent = 'Cr√©ation du fichier ZIP...';

                // G√©n√©rer le ZIP
                // ajouter le workbook d'attribution au ZIP si disponible
                if (lastAssignmentWorkbookArray) {
                    zip.file('Attribution_places.xlsx', lastAssignmentWorkbookArray);
                }

                const zipBlob = await zip.generateAsync({ type: 'blob' });

                progressFill.style.width = '100%';
                progressText.textContent = '‚úÖ T√©l√©chargement du ZIP...';

                // T√©l√©charger le ZIP
                const link = document.createElement('a');
                link.href = URL.createObjectURL(zipBlob);
                link.download = 'examens_personnalises.zip';
                link.click();

                // Message de succ√®s
                setTimeout(() => {
                    progressDiv.style.display = 'none';
                    progressFill.style.width = '0%';
                    alert(`‚úÖ Succ√®s ! ${students.length} PDFs ont √©t√© g√©n√©r√©s et t√©l√©charg√©s dans le ZIP.`);
                    generateBtn.disabled = false;
                }, 1000);

            } catch (error) {
                console.error('Erreur:', error);
                progressDiv.style.display = 'none';
                progressFill.style.width = '0%';
                generateBtn.disabled = false;
                alert('‚ùå Erreur lors de la g√©n√©ration des PDFs: ' + error.message);
            }
        }

        // ========== D√âTECTION AUTOMATIQUE DES COLONNES ==========
        function normalizeHeader(h) {
            if (!h) return '';
            return h.toString()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .toLowerCase()
                .replace(/[_\-\.,]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function isNameLike(header) {
            const h = normalizeHeader(header);
            const singleNameKeywords = ['prenom', 'pr√©nom', 'nom', 'nomprenom', 'prenomnom', 'prenom et nom', 'nom et pr√©nom', 'full name', 'fullname', 'name', 'nom complet', 'etudiant', 'student'];
            for (const k of singleNameKeywords) if (h.includes(k)) return true;
            if (/prenom.*nom|nom.*prenom|pr√©nom.*nom|nom.*pr√©nom|first\s*name.*last\s*name|last\s*name.*first\s*name/.test(h)) return true;
            const tokens = h.split(' ');
            if (tokens.length >= 2 && tokens.every(t => t.length > 1 && /^[a-z]+$/.test(t))) return true;
            return false;
        }

        function detectNameColumn(headers) {
            const normalized = headers.map(h => normalizeHeader(h));
            // 1) exact / contains
            for (let i = 0; i < normalized.length; i++) {
                if (isNameLike(normalized[i])) return { type: 'combined', indices: [i], score: 0.95, match: headers[i] };
            }
            // 2) adjacent pair detection (prenom / nom)
            const firstKeywords = ['prenom','pr√©nom','first','given'];
            const lastKeywords = ['nom','last','family','surname'];
            for (let i = 0; i < normalized.length - 1; i++) {
                const a = normalized[i], b = normalized[i+1];
                if ((firstKeywords.some(k=>a.includes(k)) && lastKeywords.some(k=>b.includes(k))) ||
                    (firstKeywords.some(k=>b.includes(k)) && lastKeywords.some(k=>a.includes(k)))) {
                    return { type: 'separate', indices: [i, i+1], score: 0.9, match: headers[i] + ' / ' + headers[i+1] };
                }
            }
            // 3) fallback heuristics
            const candidates = [];
            for (let i = 0; i < normalized.length; i++) {
                const h = normalized[i];
                if (h.split(' ').length >= 2 || /name|nom|prenom|pr√©nom/.test(h)) candidates.push({ i, h });
            }
            if (candidates.length === 1) return { type: 'combined', indices: [candidates[0].i], score: 0.6, match: headers[candidates[0].i] };
            return { type: 'none', indices: [], score: 0, match: null };
        }

        // ======= Attribution automatique des places (XLSX d'inscription) =======
        // Salles par d√©faut (modifiable dans le HTML plus tard)
        const ROOMS = [
            { name: 'VCH-2850', capacity: 201 },
            { name: 'VCH-2880', capacity: 110 }
        ];

        // derni√®re attribution en m√©moire (appliqu√©e lors de la g√©n√©ration des PDFs)
        let lastAssignments = null;
        // mapping local -> index (1..n) according to local population (most students = 1)
        let lastLocalIndexMap = null;
        // workbook binaire (Array) de l'attribution, √† inclure dans le ZIP final
        let lastAssignmentWorkbookArray = null;

        async function generateAssignments() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];
            if (!file) {
                alert('‚ö†Ô∏è Veuillez s√©lectionner le fichier d\'inscription (XLSX) avant de g√©n√©rer.');
                return;
            }
            if (!file.name.toLowerCase().endsWith('.xlsx')) {
                alert('‚ö†Ô∏è Le fichier doit √™tre au format .xlsx (inscription multi-feuilles).');
                return;
            }

            try {
                const arrayBuffer = await file.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                const allStudents = [];

                for (const sheetName of workbook.SheetNames) {
                    const sheet = workbook.Sheets[sheetName];
                    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                    if (!rows || rows.length <= 6) continue; // need header at row 6 and data starting row 7

                    const headerRow = rows[5].map(h => (h === undefined ? '' : String(h)));

                    const idxNom = detectSingleColumn(headerRow, ['nom','nom de famille','lastname','surname']);
                    const idxPrenom = detectSingleColumn(headerRow, ['prenom','pr√©nom','first','given','given name']);
                    const idxEmail = detectSingleColumn(headerRow, ['mail','email','courriel','adresse courriel','adresse']);
                    const idxNI = detectSingleColumn(headerRow, ['ni','matricule','identifiant','id','numero','numero dossier','dossier','num']);
                    const idxStatut = detectSingleColumn(headerRow, ['statut','inscription','status','etat']);

                    for (let r = 6; r < rows.length; r++) {
                        const row = rows[r] || [];
                        const last = (idxNom >= 0 ? (row[idxNom] || '') : '') || '';
                        const first = (idxPrenom >= 0 ? (row[idxPrenom] || '') : '') || '';
                        const email = (idxEmail >= 0 ? (row[idxEmail] || '') : '') || '';
                        const ni = (idxNI >= 0 ? (row[idxNI] || '') : '') || '';
                        const rawStatus = (idxStatut >= 0 ? (row[idxStatut] || '') : '') || '';

                        const status = normalizeHeader(rawStatus).includes('abandon') ? 'Abandon' : 'Pr√©sent';
                        const fullName = (String(first).trim() + ' ' + String(last).trim()).trim();
                        if (!fullName && !ni) continue;
                        allStudents.push({ name: fullName || ni, first: first, last: last, ni: String(ni).trim(), email: String(email).trim(), status, section: sheetName });
                    }
                }

                if (allStudents.length === 0) {
                    alert('Aucun √©tudiant d√©tect√© dans le fichier d\'inscription. V√©rifiez la structure (en-t√™tes en ligne 6).');
                    return;
                }

                // R√©cup√©rer les locaux s√©lectionn√©s dans l'UI (si aucun s√©lectionn√© -> alerte)
                const roomsToUse = getSelectedRooms();
                if (!roomsToUse || roomsToUse.length === 0) {
                    alert('‚ö†Ô∏è Veuillez s√©lectionner au moins un local dans l\'interface avant de g√©n√©rer l\'attribution.');
                    return;
                }

                // S√©parer les accommodements (si fournis) avant attribution
                const accomList = [];
                const remaining = [];
                if (accomNISet && accomNISet.size > 0) {
                    for (const s of allStudents) {
                        const key = (s.ni || '').toString().trim();
                        if (key && accomNISet.has(key)) {
                            accomList.push({ ...s, local: 'ACCOMMODEMENT', place: 'X' });
                        } else {
                            remaining.push(s);
                        }
                    }
                } else {
                    remaining.push(...allStudents);
                }
                    // S√©parer les accommodements (si fournis) et appliquer les exclusions par fichiers avant attribution
                    const accomList = [];
                    const remaining = [];
                    if (accomNISet && accomNISet.size > 0) {
                        for (const s of allStudents) {
                            const key = (s.ni || '').toString().trim();
                            if (key && accomNISet.has(key)) {
                                accomList.push({ ...s, local: 'ACCOMMODEMENT', place: 'X' });
                            } else if (filterExcludeNISet && filterExcludeNISet.size > 0 && key && filterExcludeNISet.has(key)) {
                                // excluded by filter: skip entirely
                                continue;
                            } else {
                                remaining.push(s);
                            }
                        }
                    } else {
                        for (const s of allStudents) {
                            const key = (s.ni || '').toString().trim();
                            if (filterExcludeNISet && filterExcludeNISet.size > 0 && key && filterExcludeNISet.has(key)) {
                                continue;
                            }
                            remaining.push(s);
                        }
                    }

                    // tri par nom de famille avant attribution (sur les √©tudiants restants)
                    remaining.sort((a, b) => {
                        const getLast = s => (s.last && String(s.last).trim()) || (s.name ? String(s.name).trim().split(/\s+/).slice(-1)[0] : '');
                        const la = getLast(a).toString();
                        const lb = getLast(b).toString();
                        return la.localeCompare(lb, 'fr', { sensitivity: 'base' });
                    });

                    const assignedRegular = assignSeatsToRooms(remaining, roomsToUse);
                    // concat√©ner les accommodements (ils restent en dehors du placement normal)
                    const assigned = assignedRegular.concat(accomList);

                // Trier les √©tudiants restant par nom de famille (ordre croissant) avant attribution
                remaining.sort((a, b) => {
                    const getLast = s => (s.last && String(s.last).trim()) || (s.name ? String(s.name).trim().split(/\s+/).slice(-1)[0] : '');
                    const la = getLast(a).toString();
                    const lb = getLast(b).toString();
                    return la.localeCompare(lb, 'fr', { sensitivity: 'base' });
                });
                // R√©partir les √©tudiants dans les salles (remplir la plus grande d'abord)
                const assignedRegular = assignSeatsToRooms(remaining, roomsToUse);
                // concat√©ner les accommodements (ils restent en dehors du placement normal)
                const assigned = assignedRegular.concat(accomList);

                // G√©n√©rer workbook d'attribution
                const sheetData = assigned.map(s => ({
                    'Pr√©nom et nom': s.name,
                    'NI': s.ni,
                    'Local': s.local,
                    'Place': s.place,
                    'adresse courriel': s.email,
                    'Accommodement': (accomNISet && accomNISet.size>0 && s.ni && accomNISet.has(String(s.ni).trim())) ? 'oui' : 'non',
                    'statut d\'inscription': s.status
                }));

                const ws = XLSX.utils.json_to_sheet(sheetData, { header: ['Pr√©nom et nom','NI','Local','Place','adresse courriel','Accommodement','statut d\'inscription'] });
                const wbOut = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wbOut, ws, 'Attribution');
                const wbArray = XLSX.write(wbOut, { bookType: 'xlsx', type: 'array' });

                // stocker en m√©moire pour r√©utilisation lors de la g√©n√©ration des PDFs
                lastAssignments = assigned;
                lastAssignmentWorkbookArray = wbArray;
                // construire le mapping local -> index (1..n) bas√© sur le nombre d'√©tudiants par local (desc)
                const counts = Object.create(null);
                for (const s of assigned) {
                    if (s.local) counts[s.local] = (counts[s.local] || 0) + 1;
                }
                const localsSorted = Object.keys(counts).sort((a,b) => counts[b] - counts[a]);
                lastLocalIndexMap = Object.create(null);
                localsSorted.forEach((loc, idx) => { lastLocalIndexMap[loc] = idx + 1; });
                alert(`‚úÖ Attribution termin√©e (${assigned.length} √©tudiants). L'attribution sera incluse dans le ZIP final.`);
            } catch (err) {
                console.error(err);
                alert('Erreur lors de la g√©n√©ration des attributions: ' + err.message);
            }
        }

        function assignSeatsToRooms(students, rooms) {
            // rooms : [{name,capacity}] - fill largest to smallest
            const sortedRooms = [...rooms].sort((a,b)=>b.capacity - a.capacity);
            const assigned = [];
            let studentIndex = 0;
            for (const room of sortedRooms) {
                for (let seat = 1; seat <= room.capacity && studentIndex < students.length; seat++) {
                    const s = students[studentIndex++];
                    assigned.push({ ...s, local: room.name, place: String(seat) });
                }
                if (studentIndex >= students.length) break;
            }
            // If still students left (more than total capacity), append them with empty local/seat
            while (studentIndex < students.length) {
                const s = students[studentIndex++];
                assigned.push({ ...s, local: '', place: '' });
            }
            return assigned;
        }

        function ensureLocalIndexMap() {
            if (lastLocalIndexMap) return lastLocalIndexMap;
            lastLocalIndexMap = Object.create(null);
            if (!lastAssignments || lastAssignments.length === 0) return lastLocalIndexMap;
            const counts = Object.create(null);
            for (const s of lastAssignments) {
                if (s.local) counts[s.local] = (counts[s.local] || 0) + 1;
            }
            const localsSorted = Object.keys(counts).sort((a,b) => counts[b] - counts[a]);
            localsSorted.forEach((loc, idx) => { lastLocalIndexMap[loc] = idx + 1; });
            return lastLocalIndexMap;
        }

        // Single action: compute assignments in-memory then generate PDFs (and optional lists)
        async function generateAll() {
            const csvFile = document.getElementById('csvFile').files[0];
            const pdfFile = document.getElementById('pdfFile').files[0];
            const evalName = document.getElementById('evalName').value.trim();
            const courseName = document.getElementById('courseName').value.trim();

            if (!csvFile || !pdfFile) {
                alert('‚ö†Ô∏è Veuillez s√©lectionner les deux fichiers (inscription et PDF)');
                return;
            }
            if (!evalName || !courseName) {
                alert('‚ö†Ô∏è Veuillez saisir le nom de l\'√©valuation et le num√©ro du cours.');
                return;
            }

            // read students from registration file (XLSX multi-sheet or CSV)
            try {
                let allStudents = [];
                if (csvFile.name.toLowerCase().endsWith('.xlsx')) {
                    const arrayBuffer = await csvFile.arrayBuffer();
                    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                    for (const sheetName of workbook.SheetNames) {
                        const sheet = workbook.Sheets[sheetName];
                        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                        if (!rows || rows.length <= 6) continue;
                        const headerRow = rows[5].map(h => (h === undefined ? '' : String(h)));
                        const idxNom = detectSingleColumn(headerRow, ['nom','nom de famille','lastname','surname']);
                        const idxPrenom = detectSingleColumn(headerRow, ['prenom','pr√©nom','first','given','given name']);
                        const idxEmail = detectSingleColumn(headerRow, ['mail','email','courriel','adresse courriel','adresse']);
                        const idxNI = detectSingleColumn(headerRow, ['ni','matricule','identifiant','id','numero','numero dossier','dossier','num']);
                        const idxStatut = detectSingleColumn(headerRow, ['statut','inscription','status','etat']);

                        for (let r = 6; r < rows.length; r++) {
                            const row = rows[r] || [];
                            const last = (idxNom >= 0 ? (row[idxNom] || '') : '') || '';
                            const first = (idxPrenom >= 0 ? (row[idxPrenom] || '') : '') || '';
                            const email = (idxEmail >= 0 ? (row[idxEmail] || '') : '') || '';
                            const ni = (idxNI >= 0 ? (row[idxNI] || '') : '') || '';
                            const rawStatus = (idxStatut >= 0 ? (row[idxStatut] || '') : '') || '';
                            const status = normalizeHeader(rawStatus).includes('abandon') ? 'Abandon' : 'Pr√©sent';
                            const fullName = (String(first).trim() + ' ' + String(last).trim()).trim();
                            if (!fullName && !ni) continue;
                            allStudents.push({ name: fullName || ni, first: first, last: last, ni: String(ni).trim(), email: String(email).trim(), status, section: sheetName });
                        }
                    }
                } else {
                    const csvText = await csvFile.text();
                    allStudents = parseCSV(csvText);
                }

                if (allStudents.length === 0) {
                    alert('Aucun √©tudiant d√©tect√© dans le fichier d\'inscription.');
                    return;
                }

                // get selected rooms and assign
                const roomsToUse = getSelectedRooms();
                if (!roomsToUse || roomsToUse.length === 0) {
                    alert('‚ö†Ô∏è Veuillez s√©lectionner au moins un local dans l\'interface avant de g√©n√©rer l\'attribution.');
                    return;
                }

                // S√©parer les accommodements (si fournis) avant attribution
                const accomList = [];
                const remaining = [];
                if (accomNISet && accomNISet.size > 0) {
                    for (const s of allStudents) {
                        const key = (s.ni || '').toString().trim();
                        if (key && accomNISet.has(key)) {
                            accomList.push({ ...s, local: 'ACCOMMODEMENT', place: 'X' });
                        } else {
                            remaining.push(s);
                        }
                    }
                } else {
                    remaining.push(...allStudents);
                }

                // tri par nom de famille avant attribution (sur les √©tudiants restants)
                remaining.sort((a, b) => {
                    const getLast = s => (s.last && String(s.last).trim()) || (s.name ? String(s.name).trim().split(/\s+/).slice(-1)[0] : '');
                    const la = getLast(a).toString();
                    const lb = getLast(b).toString();
                    return la.localeCompare(lb, 'fr', { sensitivity: 'base' });
                });

                const assignedRegular = assignSeatsToRooms(remaining, roomsToUse);
                const assigned = assignedRegular.concat(accomList);
                lastAssignments = assigned;

                // build and store local index map
                const counts = Object.create(null);
                for (const s of assigned) if (s.local) counts[s.local] = (counts[s.local] || 0) + 1;
                const localsSorted = Object.keys(counts).sort((a,b) => counts[b] - counts[a]);
                lastLocalIndexMap = Object.create(null);
                localsSorted.forEach((loc, idx) => { lastLocalIndexMap[loc] = idx + 1; });

                // proceed to generate PDFs (and lists if requested)
                await generatePDFs();
            } catch (err) {
                console.error(err);
                alert('Erreur lors du traitement : ' + err.message);
            }
        }

        function getSelectedRooms() {
            const rows = Array.from(document.querySelectorAll('#roomList .roomRow'));
            const rooms = [];
            for (const row of rows) {
                const checkbox = row.querySelector('.roomCheckbox');
                const capacityInput = row.querySelector('.roomCapacity');
                if (!checkbox || !capacityInput) continue;
                if (checkbox.checked) {
                    const name = checkbox.dataset.name || checkbox.id.replace('room_','');
                    const cap = parseInt(capacityInput.value, 10) || 0;
                    if (cap > 0) rooms.push({ name: String(name), capacity: cap });
                }
            }
            return rooms;
        }

        function detectSingleColumn(headers, keywords) {
            const normalized = headers.map(h => normalizeHeader(h));
            for (let i = 0; i < normalized.length; i++) {
                for (const k of keywords) {
                    if (normalized[i].includes(k)) return i;
                }
            }
            return -1;
        }

        // ====== UI: remplir les selects de mapping √† l'ouverture du fichier ======
        let columnHeaders = [];
        const columnMapping = {
            nameMode: 'combined', // or 'separate'
            nameIdx: null,
            firstIdx: null,
            lastIdx: null,
            niIdx: null
        };

        // Accommodements
        let accomHeaders = [];
        let accomNISet = null; // Set of NI strings
        // Filtres (exclusion via fichiers de liste)
        let filterExcludeNISet = null; // Set of NI strings to exclude when TypeInscription != 'Campus UL'

        document.getElementById('csvFile').addEventListener('change', onCsvFileSelected);
        document.getElementById('accomFile').addEventListener('change', onAccomFileSelected);
        document.getElementById('filterFiles').addEventListener('change', onFilterFilesSelected);
        document.getElementById('nameSeparate').addEventListener('change', (e) => {
            const separate = e.target.checked;
            columnMapping.nameMode = separate ? 'separate' : 'combined';
            document.getElementById('nameCombinedSelect').disabled = separate;
            document.getElementById('firstNameSelect').disabled = !separate;
            document.getElementById('lastNameSelect').disabled = !separate;
        });

        ['nameCombinedSelect','firstNameSelect','lastNameSelect','niSelect']
            .forEach(id => document.getElementById(id).addEventListener('change', () => updateMappingFromUI()));

        async function onCsvFileSelected(e) {
            const file = e.target.files[0];
            if (!file) return;
            let headers = [];
            try {
                if (file.name.toLowerCase().endsWith('.xlsx')) {
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const rows = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                    if (rows && rows.length > 5) headers = (rows[5] || []).map(h => h === undefined ? '' : h.toString());
                } else {
                    const text = await file.text();
                    const raw = text.split(/\r?\n/);
                    if (raw.length > 5) {
                        const headerLine = raw[5];
                        const sep = headerLine && headerLine.includes(';') ? ';' : (headerLine && headerLine.includes(',') ? ',' : ',');
                        headers = headerLine.split(sep).map(h => h === undefined ? '' : h.toString().trim());
                    }
                }
            } catch (err) {
                console.error('Erreur lecture en-t√™tes:', err);
            }

            columnHeaders = headers;
            if (headers.length === 0) return;

            populateAllSelects(headers);
            document.getElementById('mappingUI').style.display = 'block';

            // Pr√©-s√©lectionner √† partir de la d√©tection heuristique
            const detection = detectNameColumn(headers);
            if (detection.type === 'separate') {
                // determine which index corresponds to pr√©nom vs nom
                const norm = headers.map(h => normalizeHeader(h));
                const i0 = detection.indices[0];
                const i1 = detection.indices[1];
                const a = norm[i0] || '';
                const b = norm[i1] || '';
                const firstKeywords = ['prenom','pr√©nom','first','given'];
                const lastKeywords = ['nom','last','family','surname'];

                let firstIdx = i0;
                let lastIdx = i1;
                if (firstKeywords.some(k => a.includes(k)) || lastKeywords.some(k => b.includes(k))) {
                    firstIdx = i0; lastIdx = i1;
                } else if (firstKeywords.some(k => b.includes(k)) || lastKeywords.some(k => a.includes(k))) {
                    firstIdx = i1; lastIdx = i0;
                }

                document.getElementById('nameSeparate').checked = true;
                columnMapping.nameMode = 'separate';
                document.getElementById('firstNameSelect').value = String(firstIdx);
                document.getElementById('lastNameSelect').value = String(lastIdx);
            } else if (detection.type === 'combined') {
                document.getElementById('nameSeparate').checked = false;
                columnMapping.nameMode = 'combined';
                document.getElementById('nameCombinedSelect').value = String(detection.indices[0]);
            }

            // autres champs
            const ni = detectSingleColumn(headers, ['ni','matricule','identifiant','id','numero','num']);
            if (ni >= 0) document.getElementById('niSelect').value = String(ni);

            updateMappingFromUI();
        }

        async function onAccomFileSelected(e) {
            const file = e.target.files[0];
            accomHeaders = [];
            accomNISet = null;
            const mapDiv = document.getElementById('accomMap');
            const select = document.getElementById('accomNiSelect');
            select.innerHTML = '';
            if (!file) { if (mapDiv) mapDiv.style.display = 'none'; return; }

            try {
                if (file.name.toLowerCase().endsWith('.xlsx')) {
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const rows = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                    if (rows && rows.length) {
                        // try to find a header row containing 'matricule' or 'ni', else use first non-empty row
                        let headerRow = null;
                        for (let r = 0; r < Math.min(rows.length, 10); r++) {
                            const row = (rows[r] || []).map(c => normalizeHeader(String(c || '')));
                            if (row.some(c => /matricul|ni|identif|dossier|numero/.test(c))) { headerRow = rows[r]; break; }
                        }
                        if (!headerRow) headerRow = rows[0];
                        accomHeaders = (headerRow || []).map(h => h === undefined ? '' : String(h));
                    }
                } else {
                    const text = await file.text();
                    const raw = text.split(/\r?\n/).filter(Boolean);
                    if (raw.length) {
                        const first = raw[0];
                        const sep = first.includes(';') ? ';' : (first.includes(',') ? ',' : ',');
                        accomHeaders = first.split(sep).map(h => h === undefined ? '' : h.toString().trim());
                    }
                }
            } catch (err) {
                console.error('Erreur lecture accom:', err);
            }

            if (accomHeaders.length === 0) {
                if (mapDiv) mapDiv.style.display = 'none';
                return;
            }

            // populate select
            const none = document.createElement('option'); none.value = ''; none.textContent = '-- choisir colonne --'; select.appendChild(none);
            accomHeaders.forEach((h,idx) => {
                const o = document.createElement('option'); o.value = String(idx); o.textContent = `${idx+1}: ${h}`; select.appendChild(o);
            });

            // default to matricule-like header if present
            const norm = accomHeaders.map(h => normalizeHeader(h));
            const defaultIdx = norm.findIndex(h => /matricul|ni|identif|dossier|numero/.test(h));
            if (defaultIdx >= 0) select.value = String(defaultIdx);

            mapDiv.style.display = 'block';

            // when user changes selection, re-read selected column into accomNISet
            select.addEventListener('change', async () => {
                await buildAccomNISet(file, select.value === '' ? null : parseInt(select.value,10));
            }, { once: false });

            // build initial set
            await buildAccomNISet(file, select.value === '' ? null : parseInt(select.value,10));
        }

        async function buildAccomNISet(file, colIdx) {
            accomNISet = new Set();
            if (!file || colIdx === null || typeof colIdx === 'undefined') return;
            try {
                if (file.name.toLowerCase().endsWith('.xlsx')) {
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const rows = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                    // find the header row index used earlier
                    let headerRowIndex = 0;
                    for (let r = 0; r < Math.min(rows.length, 10); r++) {
                        const row = (rows[r] || []).map(c => normalizeHeader(String(c || '')));
                        if (row.some(c => /matricul|ni|identif|dossier|numero/.test(c))) { headerRowIndex = r; break; }
                    }
                    for (let r = headerRowIndex + 1; r < rows.length; r++) {
                        const row = rows[r] || [];
                        const v = row[colIdx];
                        if (v !== undefined && v !== null && String(v).trim() !== '') accomNISet.add(String(v).trim());
                    }
                } else {
                    const text = await file.text();
                    const raw = text.split(/\r?\n/);
                    if (raw.length) {
                        const headerLine = raw[0];
                        const sep = headerLine.includes(';') ? ';' : (headerLine.includes(',') ? ',' : ',');
                        for (let i = 1; i < raw.length; i++) {
                            const parts = raw[i].split(sep);
                            const v = parts[colIdx];
                            if (v !== undefined && v !== null && String(v).trim() !== '') accomNISet.add(String(v).trim());
                        }
                    }
                }
            } catch (err) {
                console.error('Erreur buildAccomNISet:', err);
            }
        }

        async function onFilterFilesSelected(e) {
            const files = Array.from(e.target.files || []);
            filterExcludeNISet = new Set();
            const resultDiv = document.getElementById('filterResult');
            if (!files || files.length === 0) { if (resultDiv) resultDiv.style.display = 'none'; return; }

            let totalExcluded = 0;
            for (const file of files) {
                try {
                    if (file.name.toLowerCase().endsWith('.xlsx')) {
                        const arrayBuffer = await file.arrayBuffer();
                        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                        const sheet = workbook.Sheets[workbook.SheetNames[0]];
                        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                        if (!rows || rows.length === 0) continue;

                        // try to detect header row by looking for TypeInscription-like header
                        let headerRowIndex = -1;
                        for (let r = 0; r < Math.min(rows.length, 10); r++) {
                            const norm = (rows[r] || []).map(c => normalizeHeader(String(c || '')));
                            if (norm.some(c => /typeinscription|type_inscription|type inscription|type/.test(c))) { headerRowIndex = r; break; }
                        }
                        if (headerRowIndex === -1) headerRowIndex = Math.min(2, rows.length-1);

                        const headerRow = (rows[headerRowIndex] || []).map(h => h === undefined ? '' : String(h));
                        const typeIdx = detectSingleColumn(headerRow, ['typeinscription','type inscription','type','type_inscription']);
                        const niIdx = detectSingleColumn(headerRow, ['ni','matricule','identifiant','id','numero','num','dossier']);

                        const startRow = Math.max(3, headerRowIndex + 1);
                        for (let r = startRow; r < rows.length; r++) {
                            const row = rows[r] || [];
                            const typeVal = (typeIdx >=0 ? String(row[typeIdx] || '') : '').trim();
                            if (!typeVal) continue;
                            const normType = normalizeHeader(typeVal);
                            if (normType !== 'campus ul' && normType !== 'campusul') {
                                const niVal = (niIdx >= 0 ? row[niIdx] : undefined);
                                if (niVal !== undefined && niVal !== null && String(niVal).trim() !== '') {
                                    filterExcludeNISet.add(String(niVal).trim());
                                    totalExcluded++;
                                }
                            }
                        }
                    } else {
                        const text = await file.text();
                        const raw = text.split(/\r?\n/);
                        if (raw.length <= 3) continue;
                        const headerLine = raw[2] || '';
                        const sep = headerLine.includes(';') ? ';' : (headerLine.includes(',') ? ',' : ',');
                        const headerParts = headerLine.split(sep).map(h => (h===undefined?'':h.trim()));
                        const typeIdx = detectSingleColumn(headerParts, ['typeinscription','type inscription','type','type_inscription']);
                        const niIdx = detectSingleColumn(headerParts, ['ni','matricule','identifiant','id','numero','num','dossier']);
                        for (let i = 3; i < raw.length; i++) {
                            const line = raw[i] || ''; if (!line.trim()) continue;
                            const parts = line.split(sep);
                            const typeVal = (typeIdx >= 0 ? (parts[typeIdx] || '') : '').trim();
                            if (!typeVal) continue;
                            const normType = normalizeHeader(typeVal);
                            if (normType !== 'campus ul' && normType !== 'campusul') {
                                const niVal = (niIdx >= 0 ? parts[niIdx] : undefined);
                                if (niVal !== undefined && niVal !== null && String(niVal).trim() !== '') {
                                    filterExcludeNISet.add(String(niVal).trim());
                                    totalExcluded++;
                                }
                            }
                        }
                    }
                } catch (err) {
                    console.error('Erreur lecture filter file', file.name, err);
                }
            }

            if (resultDiv) {
                resultDiv.style.display = 'block';
                resultDiv.textContent = `Fichiers: ${files.length} ‚Äî √©tudiants exclus d√©tect√©s: ${totalExcluded}`;
            }
        }

        function populateAllSelects(headers) {
            const ids = ['nameCombinedSelect','firstNameSelect','lastNameSelect','niSelect'];
            ids.forEach(id => populateSelect(id, headers));
            // enable/disable according to current mode
            const separate = document.getElementById('nameSeparate').checked;
            document.getElementById('nameCombinedSelect').disabled = separate;
            document.getElementById('firstNameSelect').disabled = !separate;
            document.getElementById('lastNameSelect').disabled = !separate;
        }

        function populateSelect(id, headers) {
            const sel = document.getElementById(id);
            sel.innerHTML = '';
            headers.forEach((h, idx) => {
                const o = document.createElement('option');
                o.value = String(idx);
                o.textContent = `${idx+1}: ${h}`;
                sel.appendChild(o);
            });
            const none = document.createElement('option');
            none.value = '';
            none.textContent = '-- non d√©fini --';
            sel.insertBefore(none, sel.firstChild);
        }

        function updateMappingFromUI() {
            const separate = document.getElementById('nameSeparate').checked;
            columnMapping.nameMode = separate ? 'separate' : 'combined';
            columnMapping.nameIdx = document.getElementById('nameCombinedSelect').value === '' ? null : parseInt(document.getElementById('nameCombinedSelect').value,10);
            columnMapping.firstIdx = document.getElementById('firstNameSelect').value === '' ? null : parseInt(document.getElementById('firstNameSelect').value,10);
            columnMapping.lastIdx = document.getElementById('lastNameSelect').value === '' ? null : parseInt(document.getElementById('lastNameSelect').value,10);
            columnMapping.niIdx = document.getElementById('niSelect').value === '' ? null : parseInt(document.getElementById('niSelect').value,10);
        }

        function parseCSV(csvText) {
            csvText = csvText.replace(/^\uFEFF/, '');
            const rawLines = csvText.split(/\r?\n/);
            const students = [];
            if (rawLines.length <= 5) return students;

            // D√©tecter s√©parateur √† partir de la ligne d'en-t√™te (ligne 6)
            const headerLine = rawLines[5] || '';
            const sep = headerLine.includes(';') ? ';' : (headerLine.includes(',') ? ',' : ',');
            const headers = headerLine.split(sep).map(h => (h === undefined ? '' : h.trim()));

            const detection = detectNameColumn(headers);

            const niKeywords = ['ni','matricule','identifiant','id','numero','num','matricule'];
            const niIndex = detectSingleColumn(headers, niKeywords);

            // Afficher le r√©sultat de la d√©tection pour l'utilisateur (nom + NI)
            const mappingLines = [];
            if (detection.type !== 'none') {
                mappingLines.push(`<strong>D√©tection nom:</strong> ${detection.match} (type: ${detection.type}, score: ${Math.round(detection.score*100)}%)`);
            } else {
                mappingLines.push('<strong>D√©tection nom:</strong> non trouv√©e ‚Äî utilisation des positions par d√©faut');
            }
            mappingLines.push(`<strong>NI:</strong> ${niIndex>=0 ? headers[niIndex] : 'non d√©tect√©'}`);
            const detDiv = document.getElementById('detectionResult');
            if (detDiv) detDiv.innerHTML = mappingLines.join('<br>');

            // Fallback indices par d√©faut
            const fallback = { nameIdx: 0, niIdx: 1 };
            const nameIsSeparate = (detection.type === 'separate' && detection.indices.length === 2);

            for (let i = 6; i < rawLines.length; i++) {
                const line = rawLines[i] || '';
                if (!line.trim()) continue;
                const parts = line.split(sep);

                let name = '';
                if (columnMapping.nameMode === 'separate') {
                    const a = (columnMapping.firstIdx !== null ? parts[columnMapping.firstIdx] : '') || '';
                    const b = (columnMapping.lastIdx !== null ? parts[columnMapping.lastIdx] : '') || '';
                    name = (a + ' ' + b).trim();
                } else {
                    if (columnMapping.nameIdx !== null) {
                        name = (parts[columnMapping.nameIdx] || '').trim();
                    } else if (detection.indices.length === 1 && detection.indices[0] >= 0) {
                        name = (parts[detection.indices[0]] || '').trim();
                    } else {
                        name = (parts[fallback.nameIdx] || '').trim();
                    }
                }

                const ni = (columnMapping.niIdx !== null ? (parts[columnMapping.niIdx] || '') : (niIndex >= 0 ? (parts[niIndex] || '') : (parts[fallback.niIdx] || ''))).trim();
                const table = '';
                const local = '';
                const section = '';

                if (name || ni) {
                    students.push({ name: name || ni, ni, table, local, section });
                }
            }

            console.log('√âtudiants pars√©s:', students);
            return students;
        }

        function toggleListFields() {
                    // legacy: removed listOption select; no-op
        }

        async function generateAttendancePDF(studentsGroup, groupBy, groupValue, evalName, courseName) {
            const pdfDoc = await PDFDocument.create();
            const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
            const fontBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

            // Trier : par num√©ro de table (croissant) si par local, alphab√©tique si par section
            const sorted = [...studentsGroup].sort((a, b) => {
                if (groupBy === 'local') {
                    return parseInt(a.table, 10) - parseInt(b.table, 10);
                }
                return a.name.localeCompare(b.name, 'fr');
            });

            // Configuration du tableau
            const pageWidth = 612; // Lettre portrait
            const pageHeight = 792;
            const margin = 40;
            const titleSize = 13;
            const headerSize = 10;
            const rowSize = 10;
            const rowHeight = 22;
            const headerHeight = 25;
            const colWidths = [190, 75, 55, 75, 65]; // Nom, Matricule, Table, Section/Local, Pr√©sence
            const tableTop = pageHeight - margin - 45;

            // En-t√™tes selon le mode
            let headers, fourthColLabel;
            if (groupBy === 'local') {
                headers = ['Nom', 'Matricule', 'Table', 'Section', 'Pr√©sence'];
                fourthColLabel = 'section';
            } else {
                headers = ['Nom', 'Matricule', 'Table', 'Local', 'Pr√©sence'];
                fourthColLabel = 'local';
            }

            // Titre
            const titleLabel = groupBy === 'local' ? 'Local' : 'Section';
            const title = `Feuille de pr√©sence - ${evalName} - ${courseName} - ${titleLabel} ${groupValue}`;

            // Nombre d'√©tudiants par page
            const rowsPerPage = Math.floor((tableTop - margin - headerHeight) / rowHeight);

            let pageIndex = 0;
            let studentIndex = 0;

            while (studentIndex < sorted.length) {
                const page = pdfDoc.addPage([pageWidth, pageHeight]);
                let y = pageHeight - margin;

                // Titre
                const titleWidth = fontBold.widthOfTextAtSize(title, titleSize);
                page.drawText(title, {
                    x: (pageWidth - titleWidth) / 2,
                    y: y,
                    size: titleSize,
                    font: fontBold,
                    color: rgb(0, 0, 0),
                });
                y -= 35;

                // Calculer le d√©but X du tableau (centr√©)
                const totalTableWidth = colWidths.reduce((a, b) => a + b, 0);
                const tableX = (pageWidth - totalTableWidth) / 2;

                // En-t√™te du tableau - fond gris
                page.drawRectangle({
                    x: tableX,
                    y: y - headerHeight + 5,
                    width: totalTableWidth,
                    height: headerHeight,
                    color: rgb(0.85, 0.85, 0.85),
                });

                // Dessiner les en-t√™tes
                let colX = tableX;
                for (let c = 0; c < headers.length; c++) {
                    page.drawText(headers[c], {
                        x: colX + 5,
                        y: y - 12,
                        size: headerSize,
                        font: fontBold,
                        color: rgb(0, 0, 0),
                    });
                    colX += colWidths[c];
                }

                // Ligne sous l'en-t√™te
                y -= headerHeight;

                // Lignes de donn√©es
                const rowsOnThisPage = Math.min(rowsPerPage, sorted.length - studentIndex);
                for (let r = 0; r < rowsOnThisPage; r++) {
                    const student = sorted[studentIndex];
                    const rowY = y - (r * rowHeight);

                    // Alternance de couleur de fond
                    if (r % 2 === 0) {
                        page.drawRectangle({
                            x: tableX,
                            y: rowY - rowHeight + 5,
                            width: totalTableWidth,
                            height: rowHeight,
                            color: rgb(0.95, 0.95, 1),
                        });
                    }

                    // Donn√©es
                    const rowData = [
                        student.name,
                        student.ni,
                        student.table,
                        student[fourthColLabel],
                        '' // case vide pour pr√©sence
                    ];

                    colX = tableX;
                    for (let c = 0; c < rowData.length; c++) {
                        if (c === 4) {
                            // Case √† cocher vide (petit carr√©)
                            page.drawRectangle({
                                x: colX + 25,
                                y: rowY - 12,
                                width: 14,
                                height: 14,
                                borderColor: rgb(0, 0, 0),
                                borderWidth: 1,
                                color: rgb(1, 1, 1),
                            });
                        } else {
                            // Tronquer le texte si trop long
                            let text = rowData[c];
                            const maxWidth = colWidths[c] - 10;
                            while (font.widthOfTextAtSize(text, rowSize) > maxWidth && text.length > 1) {
                                text = text.slice(0, -1);
                            }
                            page.drawText(text, {
                                x: colX + 5,
                                y: rowY - 12,
                                size: rowSize,
                                font,
                                color: rgb(0, 0, 0),
                            });
                        }
                        colX += colWidths[c];
                    }

                    // Lignes horizontales
                    page.drawLine({
                        start: { x: tableX, y: rowY - rowHeight + 5 },
                        end: { x: tableX + totalTableWidth, y: rowY - rowHeight + 5 },
                        thickness: 0.5,
                        color: rgb(0.8, 0.8, 0.8),
                    });

                    studentIndex++;
                }

                // Bordures verticales du tableau
                const tableBottom = y - (rowsOnThisPage * rowHeight) + 5;
                const tableTopY = y + 5;
                colX = tableX;
                for (let c = 0; c <= colWidths.length; c++) {
                    page.drawLine({
                        start: { x: colX, y: tableTopY },
                        end: { x: colX, y: tableBottom },
                        thickness: 0.5,
                        color: rgb(0.6, 0.6, 0.6),
                    });
                    if (c < colWidths.length) colX += colWidths[c];
                }

                // Bordure ext√©rieure
                page.drawRectangle({
                    x: tableX,
                    y: tableBottom,
                    width: totalTableWidth,
                    height: tableTopY - tableBottom,
                    borderColor: rgb(0.4, 0.4, 0.4),
                    borderWidth: 1,
                });

                pageIndex++;
            }

            return await pdfDoc.save();
        }

        function sanitizeFileName(name) {
            // Remplacer les caract√®res sp√©ciaux par des underscores
            return name
                .replace(/[^a-zA-Z0-9√Ä-√ø\-]/g, '_')
                .replace(/_+/g, '_')
                .replace(/^_|_$/g, '');
        }

        function buildFileBase(student) {
            const name = (student && student.name) ? String(student.name).trim() : '';
            let first = student && student.first ? String(student.first).trim() : '';
            let last = student && student.last ? String(student.last).trim() : '';

            if (!last && name) {
                const parts = name.split(/\s+/).filter(Boolean);
                if (parts.length > 1) {
                    last = parts[parts.length - 1];
                    first = parts.slice(0, parts.length - 1).join(' ');
                } else {
                    last = parts[0] || '';
                    first = '';
                }
            }

            const parts = [];
            if (last) parts.push(last);
            if (first) parts.push(first);
            const base = parts.join('_') || (student && student.ni ? String(student.ni) : 'student');
            return sanitizeFileName(base);
        }

        // Permettre le glisser-d√©poser
        ['csvFile', 'pdfFile'].forEach(id => {
            const input = document.getElementById(id);
            const parent = input.parentElement;

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                parent.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                parent.addEventListener(eventName, () => {
                    input.style.borderColor = '#764ba2';
                    input.style.background = '#f0f1ff';
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                parent.addEventListener(eventName, () => {
                    input.style.borderColor = '#667eea';
                    input.style.background = '#f8f9ff';
                }, false);
            });

            parent.addEventListener('drop', (e) => {
                const dt = e.dataTransfer;
                const files = dt.files;
                input.files = files;
            }, false);
        });
    </script>
</body>
</html>
